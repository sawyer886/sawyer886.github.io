---

author: warrel

catalog: 基础

---

# shell 中通过命名管道实现并行控制

## 一.前置知识

### 1.1 后台运行命令

`command &` 表示命令在后台运行,当用户会话退出的时候命令也会退出

`nohup command ` 表示不挂断的运行

`wait command` 表示等之前的命令(当前进程下的子进程)都执行完再执行后面的命令

`jobs ` 查看当前会话后台运行任务

通常挂在后台运行都会结合**nohup** 和 **&** 来使用 `nohup command &`  例如运行一个脚本将错误输出和标准输出都输出到日志文件

```sh
nohup sh test.sh > test.log 2>&1 &
```

### 1.2 重定向和文件描述符

 重定向分为输入重定向和输出重定向 和混合重定向

#### 1.2.1 输入重定向

输入重定向分为  **<** 和 **<<** ，两者的区别是： __<__ 表示无界读取，**<<** 表示可以指定标识符读取, 例如指定标识符**EOF**读取键盘输入:

```sh
cat <<EOF
hello world!
EOF
# 会打印 hello world!
```

会直接打印以指定标识符开始和结束中间的内容

  **<** 表示从键盘读取输入，**< file** 表示从文件中读取作为输入

#### 1.2.2 输出重定向

输出重定向分为: **>** 和 **>>**  , 两者的区别是：**> file** 表示先删除在写入  **>> file ** 表示每次都是追加写入

#### 1.2.3 混合重定向

  既包括输入重定向又包括输出重定向：

例如: `cat < file1 > file2`   标识将file1的内容读取出来，并且输出的file2文件中

#### 1.2.4 文件描述符

linux中的文件描述符在形式上是一个大于0的整数，自定义的要大于2，不和系统自带的冲突，小于**ulimit -n**，指向操作系统给每个进程所维护的该进程打开的文件列表。在默认情况下总是有三个文件是出于打开状态的，标准输入，标准输出，错误输出，它们分别对应的文件描述符为:**0,1,2**  与上面讨论的重定向的关系：输入重定向 **<** ，输出重定向 **>**  和 **>>**  等价于 **1>** 和 **1>>** , 错误重定向: **2>** 和 **2>>**

#### 1.2.5重定向输出和输入文件描述符

  可以使用`exec fd <|> file`   命令来重定向输入或输出到文件 其中**fd**表示描述符一般取**0，1，2**之外的来定义新的描述符：

##### 重定向标准输入

`exec fd < input_file` 

  例如可以通过下面来重定向标准输入到文件输入:

```sh
# 定义fd 3 表示从 文件input_file读取输入
exec 3< input_file
#把标准输入fd 0 重定向给 fd3
exec 0<&3
while read line
do
   echo "$line"
done
# 或者直接将标准输入改的文件标识符改为文件输入
exec 0< input_file
while read line
do
   echo "$line"
done
```

##### 重定向标准/错误输出

`exec fd > ouput_file` 

例如可以通过下面来重定向标准输出到文件输出:

```
# 定义fd 4 表示输出到文件 output_file
exec 4> output_file
echo "aaa" >&4
# 直接把标准错误都输出到output_file
exec > output_file 2>&1
echo "bbbb"
```

##### 创建输入输出描述符

`exec fd <> file` 表示创建输入输出描述符 fd 到文件(可读可写)

例如通过下面例子通过标识符5来控制文件输入和输出

```
exec 5<> test.txt
while read line <&5
do
  echo "read :$line"
done
echo "read completed ....." >&5
```

##### 关闭文件描述符

`exec fd>&-` 或者 `exec fd<&- ` 关闭文件描述符

下面的例子展示了关闭了描述符就无法输入输出了

```
exec 5<> test.txt
cat <&5
# exec 5<&-
# 此句执行后后面的就无法执行了，会报错: Bad file descriptor
exec 5>&-
cat <&5
echo "aaa" > &5
```



### 1.3 管道

管道代表一个阻塞队列流，文件内容只能读取一次，没有内容则一直阻塞，分为匿名管道和命名管道

#### 1.3.1 匿名管道

shell中用`|` 表示管道，表示将前一个命令的结果给下一个命令当作输入，例如 `echo aaa | wc -c `  来统计字符个数

#### 1.3.2 命名管道

通过`mkfifo file` 命令来创建命名管道也叫先进先出队列，管道创建后删除文件对管道没有影响

例如创建一个test管道：

```sh
mkfifo /tmp/test
```

#### 1.3.3 命名管道与自定义文件描述符结合

   ```
# 创建一个命名管道，以当前进程id为文件名
mkfifo /tmp/$$.fifo
# 定义一个文件描述符与管道绑定
exec 6<> /tmp/$$.fifo
# 删除文件，不影响文件描述符,释放文件资源
rm /tmp/$$.fifo
# 向文件描述符中写入内容
echo 1111 >&6
echo 222 >&6
# 通过read -u fd 命令指定标识符按行读取
read -u 6 line; echo $line
read -u 6 line; echo $line
# 最后关闭文件描述符，释放资源
exec 6>&-

   ```



## 二. 通过命名管道和自定义文件描述符来控制并行

###  2.1 并行原理

通过命名管道并且关联一个文件描述符，向管道(文件标识符)中每次写入**max_process** 个信号量(最大运行的标记)，任务运行的时候先取信号量，取完**max_process**个信号量后，管道中没有数据了，则不会获取到任务来执行。同时任务执行后要释放信号量，以便后续任务获取到信号量来执行，最后删除掉文件标识符和队列释放资源

![shell管道控制并行原理图](/assets/images/shell-命名队列原理图.png)

###    2.2 模板代码

```sh
#!/bin/bash
#

# 通过命名管道+自定义文件标识符来实现shell的并行控制

# 定义最大并进程数量

max_process=$1

# 根据进程名称创建命名队列(只要文件名不存在就行)

mkfifo /tmp/$$.fifo

# 分配描述符

exec 6<> /tmp/$$.fifo

# 防止忘记，先删除文件，但是不会影响描述符

rm /tmp/$$.fifo

# 向管道中添加$max_process个信息量(最大并行数量)

for i in $(seq $max_process)
    do
        echo >&6
    done
#任务循环并且读取管道中的信号量进行任务并行执行
for i in $(seq 20)
    do
        # 读取指定管道中的一条记录，读到$max_process就会停止
        read -u 6
		{
		 sleep 3
		 echo "$(date +'%Y-%m-%d %H:%M:%S')----------$i"
		 # 释放信号量 即将信号量还回，因为读取一次信号量就没有了，还回就是把信号量重新加回去
		 echo >&6
		}&
    done
wait
echo "all task completed !"

# 关闭文件描述符

exec 6>&-

```



